# erasure code 模块

### 一、安装

**lrc-erasure-code文件夹内的源文件需单独安装，安装步骤：**

**进入该文件夹，运行**

```bash
./configure
make
sudo make install
```

**即可安装成功**

**检验是否安装成功，可进入test文件夹，运行：**

```bash
gcc example.c -o example -llrc
./example
```

**此处检验时可能会出现编译或执行文件无法链接动态库的现象，需手动将动态库加到系统环境变量中，具体方法在上步安装完毕后的说明信息中介绍了4种。**

**module文件夹内为其他源文件，包括：**

**split.c——负责文件分块**

**combine.c——负责文件合并**

**check.c——负责文件检验**

**md5_file.c、md5.h、md5.c——负责文件md5校验值生成**

**upload.c——上传文件之前需执行的代码(包括文件分块、校验生成、ec编码)**

**download.c——下载文件之后需执行的代码(包括文件校验、ec译码、文件合并)**

**这些源文件在引用时只需include upload.c 和download.c 即可，同时需在文件中include"md5_file.c" 和 "lrc.h"，注意这些文件必须放在同一文件夹内。**

###二、文件分块

**五个块大小：2K、32K、256K、4M、64M**

- **小于等于128K的文件采用2K大小的块进行分块**

- **128K~1M的文件采用32K大小的块进行分块**

- **1M~16M的文件采用256K大小的块进行分块**

- **16M~256M的文件采用4M大小的块进行分块**

- **256M以上的文件采用64M大小的块进行分块**

  **块数目一般不超过64个**  

**本地块数量为4，全局块数量为每4个数据块一个。**

**本地块要放在专门的本地块目录中。**

**注意：因为erasure code本地块限制，块数量不能少于4个，也就是暂不支持小于8K的文件。(这个要求是合理的，为了避免文件系统的碎片化，因为过小的文件常常是依赖文件，意义不大。)**

### 三、文件校验

**在分块后会生成文件块的16位md5校验值，并写入文件名中，生成的code块也会生成md5校验值**

**在恢复文件时，若生成的md5校验值与文件名中的不符，则认为文件块失效。**

### 四、文件名规则

**块文件名按照“原文件名-最后一块的字节数-数据块数-编码块数-块序号(数据块和编码块单独编号)-1/0(1代表数据块，2代表编码块)-md5校验值.tmp”格式命名。**

### 五、ec

**按照lrc的规则，每个文件会生成4个本地编码块放在单独的文件夹中，其余的数据块和编码块可以分发出去，当损失的块数少于global编码块+1时，可保证恢复，若损失的块数等于全部编码块数，则恢复的几率只有80%左右。这个要求是合理的，因为本地编码块一般不会损坏，相当于还是只用收回数据块数的有效块数即可恢复。**

### 六、接口

```
download(char **path,int block_num)
```

**需要将全部回收得到的块的完整地址放入path数组中(可乱序)，再将回收得到的块数计入block_num。**

**注意，至少1个本地编码块的地址必须放入path，否则会导致程序执行错误！**

```
upload(char *filename,char *path,char *localblocks_path)
```

**将原文件名放入filename，将原文件所在目录地址放入path（注意：path需以“/”结尾），本地编码块的地址放入localblocks_path（同样localblocks_path需以“/”结尾）**

### 七、运行流程

**上传之前——编码：**

**1、通过upload接口获得需要分块冗余的原文件**

**2、调用split函数，检测文件大小，按照文件分块中陈述的规则进行分块**

**3、此时分得的块都是数据块，调用lrc_init_n,lrc_buf_init函数初始化lrc模块**

**4、将分得数据块写入buf中，调用lrc_encode函数生成编码块(4个local编码块+每4个数据块1个global编码块)**

**5、所有的数据块和编码块都会调用md5_file函数生成16位的md5校验值**

**6、调用lrc_destroy,lrc_buf_destroy函数释放申请的内存空间，释放资源**

**下载之后——译码：**

**1、通过download接口获得需要文件块**

**2、调用check函数，通过检验文件生成的md5值与文件名中的md5值来比较，校验文件是否损坏。同时从文件名中获取原文件的一些基本信息，以便恢复原文件**

**3、调用lrc_init_n,lrc_buf_init函数初始化lrc模块**

**4、调用lrc_get_source函数检测恢复文件需要的文件块以及检验是否能够恢复文件**

**5、将lrc_get_source函数指定的文件块写入buf中，调用lrc_decode恢复数据块**

**6、调用combine函数将数据块合成为原文件**

**7、调用lrc_destroy,lrc_buf_destroy函数释放申请的内存空间，释放资源**

### 八、亮点

**1、增加本地块**

**增加一些本地块虽然会多占用少部分约10%左右的空间，但是会将I/O的消耗降低至没有本地块时的10~50%。**

**2、集成GF-complete（伽罗瓦运算库）采用多种矩阵(如柯西矩阵、范德蒙德矩阵)计算编码块，同时优化算法提升计算的速度，尽量降低erasure code的延迟。**